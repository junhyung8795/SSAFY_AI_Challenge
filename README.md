# SSAFY 14기 AI 챌린지

## 팀명: 미어캣트리오

* **팀장:** 박준형
* **팀원:** 정세호, 박지우

-----

## 1. 성과

총 245개 팀 중 **score 0.96809**로 **7등**을 달성했습니다.
<img width="1440" height="775" alt="스크린샷 2025-11-21 오전 12 05 50" src="https://github.com/user-attachments/assets/07424d74-04b6-49ce-b3e4-2e163a2f1a55" />

<img width="1440" height="774" alt="스크린샷 2025-11-21 오전 12 12 47" src="https://github.com/user-attachments/assets/9a6f69fe-e95e-4c25-9636-ca5b412e7c05" />


-----

## 2. 대회개요

**‘SSAFY 14기 AI 챌린지’** 는 SSAFY 14기 대상으로 이미지 기반 질의응답 모델 개발을 목표로 진행한 대회입니다. 참가자들은 일상 이미지 데이터를 활용하여 Visual Question Answering(VQA) 모델을 개발하고, 이를 통해 다양한 질문에 답변할 수 있는 시스템을 구축합니다. 본 대회는 AI 이론과 실습을 심화하며, 문제 해결 능력을 배양하고 실제 프로젝트에 효과적으로 적용할 수 있는 역량을 강화하는 것을 목적으로 합니다.

* **대회 주제:** 이미지 기반 질의응답 모델 개발
* **데이터셋:**
    * 데이터 수집 미션으로 수집된 이미지 중 일부를 퀴즈 형태로 가공
    * 이미지와 관련된 Question-Answering 쌍 데이터 제공
    * **예시:**
      > 질문: 이 사진에서 보이는 탈것은 무엇인가요?
      > 선지: a.오토바이 b.세발 오토바이 c.자전거 d.자동차
      > 정답: b
* **평가 기준:**
    * 모델의 정확도(Accuracy)
    * 데이터셋에 대한 재현성
    * 모델의 효율성 및 성능
<img width="1012" height="325" alt="image" src="https://github.com/user-attachments/assets/3c65e3ed-2eed-454b-b824-3aaf947abc71" />

-----

## 3. 모델 선정

### 사용 파운데이션 모델

**unsloth/Qwen3-VL-8B-Instruct-unsloth-bnb-4bit**: Unsloth로 최적화된 Qwen3-VL 8B 모델을 4비트 양자화하여 사용했습니다.

### 모델 선정 이유

A100 40GB라는 **제한된 GPU VRAM 환경** 속에서 최고의 성능을 내는 것이 목표이기 때문에 이 목표를 고려하여 모델을 전략적으로 선택

* **Hugging Face의 'image-text-to-text' 모델 선택:**
  단순 이미지 분류기(CNN)와 달리, 이미지를 입력받아 텍스트(정답 'a', 'b', 'c', 'd')를 직접 생성하는 Hugging Face의 image-text-to-text 파이프라인 모델(Qwen-VL)을 채택했습니다.
* **4bit 양자화 버전 사용 :** Out-of-Memory (OOM) 에러를 피하기 위한 필수 선택. 8B 모델을 40GB VRAM 제약 내에 로드하고 훈련하기 위해 VRAM 사용량을 획기적으로 줄였습니다.
* **Unsloth 버전 사용 :** 훈련 속도와 메모리 효율을 극대화하기 위함입니다. 표준 QLoRA 대비 2배 빠른 훈련 속도로 제한된 시간 내 더 많은 실험을 가능하게 했습니다.

-----

## 4. 기술 스택, 라이브러리

### 기술 스택:

* **라이브러리:**
    * `unsloth`: 효율적인 모델 파인튜닝 및 최적화 라이브러리
    * `transformers`: Hugging Face 모델 및 도구 활용
    * `trl`: SFTTrainer를 사용한 지도 미세조정
    * `wandb`: 실험 추적 및 모니터링
    * `pandas`: 데이터 처리 및 분석
    * `PIL (Pillow)`: 이미지 전처리
    * `torch`: 딥러닝 모델 구축 및 연산
    * `datasets`: 데이터셋 로딩 및 관리
    * `tqdm`: 진행률 표시
    * `math`: 수학적 계산
* **핵심 기술:**
    * `LoRA (Low-Rank Adaptation)`: 효율적인 모델 파인튜닝 기법 (r=32, lora\_alpha=32, lora\_dropout=0.05, use\_rslora=True)
    * `4비트 양자화`: 모델 메모리 최적화
    * `혼합 정밀도 학습 (bfloat16/float16)`: 학습 및 추론 속도 향상
    * `그라디언트 누적`: 효과적인 배치 크기 활용
    * `코사인 학습률 스케줄러`: 학습 안정화 및 성능 향상
    * `Packing`: 데이터 처리 효율 증대
    * `Few-Shot Prompting`: 모델 답변 유도
    * `어휘 제한`: 답변 형식 강제
    * `하이퍼파라미터 튜닝`: 최적의 학습 성능을 위한 다양한 파라미터(LoRA 설정, 학습률, 에폭 등) 탐색 및 적용
    * `이미지 전처리`: 모델 입력 크기에 맞추기 위한 이미지 리사이징 및 필요시 패딩 처리
    * `Softmax 기반 추론`: 모델의 마지막 레이어 출력에 Softmax 함수를 적용하여 각 보기(a, b, c, d)에 대한 확률을 계산하고, 가장 높은 확률을 가진 보기를 최종 답변으로 선택
* **환경:**
    * `Kaggle`: 대회 플랫폼
    * `Google Colab (A100 40GB GPU)`: 주요 학습/추론 환경
    * `Google Drive`: 데이터/결과 저장 (옵션)
    * `CUDA`: GPU 가속 활용

-----

## 5. 성능 향상을 위한 전략

### (1) Prompt Engineering

모델이 단순히 답을 추측하지 않고 논리적으로 사고하도록 **Chain-of-Thought 프롬프트 구조**를 도입했습니다.
관찰 $\rightarrow$ 추론 $\rightarrow$ 결론의 단계적 프롬프트 구성으로모델의 자기 점검 능력과 정확도를 향상시켰습니다.
Few-shot 예시를 추가하여 모델이 학습해야 할 정답 패턴을 명확히 인식하도록 했습니다.

**프롬프트**

```python
SYSTEM_INSTRUCT = ("""
<|im_start|>system
당신은 논리적인 추론가이자 시각 분석 전문가입니다.

각 이미지와 질문에 대해, 다음 3단계 사고 과정을 거쳐 답변을 생성하세요.
1.  **관찰:** 이미지에서 질문과 관련된 핵심적인 시각 정보(사물, 텍스트, 상황 등)를 객관적으로 서술합니다.
2.  **추론:** 관찰한 내용을 바탕으로, 질문의 의도에 맞춰 어떤 보기가 정답인지 논리적인 과정을 단계별로 설명합니다.
3.  **최종 답변:** 모든 추론을 종합하여, `최종 답변: [알파벳]` 형식으로 명확하게 결론을 내립니다.

---
**Few-Shot 예시**

**예시 1:** 원형 표지판에 “40 km/h”가 적혀 있는 도시 도로
질문: "이 도시의 제한 속도는 얼마인가요?"
보기: (a) 40 km/h (b) 60 km/h (c) 80 km/h (d) 100 km/h
**관찰:** 이미지 중앙에 원형 교통 표지판이 있으며, 그 안에 '40 km/h'라는 텍스트가 명확하게 보입니다.
**추론:** 질문은 이 지역의 '제한 속도'를 묻고 있습니다. 표지판의 '40 km/h'는 '시속 40킬로미터'를 의미하며, 이는 차량의 최대 허용 속도를 나타내는 교통 규제입니다. 따라서 보기 a가 표지판의 내용과 일치합니다.
**최종 답변: a**

**예시 2:** 기념비 옆에 쌓여 있는 돌탑들
질문: "이 사진에서 볼 수 있는 돌탑들의 주요 목적은 무엇인가요?"
보기: (a) 기념과 소원을 위한 돌탑 쌓기 (b) 돌을 분류하기 위한 작업 (c) 예술 작품 전시를 위한 조형물 (d) 건축 자재로 사용하기 위한 돌 쌓기
**관찰:** 여러 크기의 돌들이 사람이 인위적으로 쌓아 올린 탑 형태를 이루고 있습니다. 주변 배경은 자연 또는 기념 장소로 보입니다.
**추론:** 한국 문화에서 이러한 돌탑은 주로 소원을 빌거나 무언가를 기념하기 위해 쌓는 민속적인 행위입니다. 다른 보기인 분류, 예술, 건축 자재 등은 일반적인 돌탑의 목적과 거리가 멉니다. 따라서 보기 a가 가장 적절한 설명입니다.
**최종 답변: a**

**예시 3:** 거리의 자동판매기
질문: "이 이미지에서 볼 수 있는 장치의 주된 용도는 무엇인가요?"
보기: (a) 물품을 보관하는 무인 보관함 (b) 자동 판매기 (c) 음식을 조리하는 전자레인지 (d) 인터넷 검색용 키오스크
**관찰:** 이미지에는 유리창 너머로 캔이나 병과 같은 다양한 음료가 진열된 기계가 보입니다. 돈이나 카드를 넣는 투입구와 하단에 물건이 나오는 배출구가 있습니다.
**추론:** 이 장치는 사람이 없이 상품을 진열하고 결제 시스템을 통해 자동으로 판매하도록 설계되었습니다. 이는 '자동 판매기'의 정의와 정확히 일치합니다. 다른 보기인 보관함, 전자레인지, 키오스크는 시각적 증거와 맞지 않습니다.
**최종 답변: b**
<|im_end|>
""")
```

### (2) 이미지 전처리

모든 이미지를 `512x512` 크기로 통일하되,
**원본 비율을 유지하고 여백을 패딩으로 채우는 방식** 사용했습니다.
왜곡된 이미지를 학습하는 문제를 해결할 수 있고
객체의 형태 보존 및 일반화 성능 향상되는 효과를 가져올 수 있습니다.

| 구분 | 패딩 없음 | 패딩 적용 |
| :--- | :---: | :---: |
| **이미지 형태** | 왜곡 | 원본 유지 |
| **학습 효율** | 낮음 | 높음 |
| **일반화 성능**| 저하 | 향상 |
*패딩처리 / 강제변환*

### (3) Softmax 기반 추론

Qwen3는 생성형 AI모델이기에 파인튜닝을 진행하더라도 문맥은 비슷하지만 간혹 a, b, c, d라는 4가지 중 하나로 답하지 않는 경우가 있습니다. 따라서 생성되는 문자열을 그대로 받아서 a, b, c, d라는 문자가 포함되면 해당 문자를 답으로 반환할 경우 오답 처리가 될 수 있습니다.

**해결 방안:** 단순 문자열 디코딩 대신 **Softmax 확률값 기반 추론**을 적용했습니다. 문장 내 포함된 문자를 단순 추출하던 기존 방식의 한계를 개선하여 의미적으로 가장 유사한 선택지를 선택하도록 유도했습니다.

**출력 문자열 디코딩 기반 추론 코드**

```python
# 모델의 응답에서 정답(a, b, c, d)만 추출하는 함수
def extract_choice(text: str) -> str:
    text = text.strip().lower()
    lines = [l.strip() for l in text.splitlines() if l.strip()]
    if not lines:
        return "a" # 응답이 없는 경우 'a'로 대체
    last = lines[-1]
    if last in ["a", "b", "c", "d"]:
        return last
    tokens = last.split()
    for tok in tokens:
        if tok in ["a", "b", "c", "d"]:
            return tok
    **return "a" #** 정답을 찾지 못한 경우 'a'로 대체
    
 #기존에는 답을 생성하면 해당 답을 그대로 디코딩했다.
 outputs = model.generate(
        **inputs,
        max_new_tokens=MAX_NEW_TOKENS,
        use_cache=True
    )

    # skip_special_tokens=True로 특수 토큰 제거
    text = tokenizer.decode(outputs[0], skip_special_tokens=True)
    preds.append({"id": row["id"], "answer": extract_choice(text)})
```

**Softmax기반 추론 코드**

```python
outputs = model.generate(**inputs, **gen_kwargs)

# 마지막 토큰 확률분포
scores = outputs.scores[-1][0]   # [vocab_size]
probs = F.softmax(scores, dim=-1)

# 각 보기 확률 = 해당 보기의 가능한 단일토큰 id들의 확률 합
def prob_of(ids):
		if not ids:
				return -1.0  # 안전장치 (토큰이 전혀 못 모였을 경우)
		return float(probs[ids].sum().item())

//각 문자와 의미가 유사할 확률들 
p_a = prob_of(A_IDS)
p_b = prob_of(B_IDS)
p_c = prob_of(C_IDS)
p_d = prob_of(D_IDS)

probs_dict = {"a": p_a, "b": p_b, "c": p_c, "d": p_d}
pred = max(probs_dict, key=probs_dict.get)

preds.append({"id": row["id"], "answer": pred})
```

결과적으로 **score가 0.94187 $\rightarrow$ 0.94598로 향상**됐습니다.

### (4) 학습률 (Learning Rate): 사전 학습 지식 손상 최소화

모델이 이미 방대한 지식을 사전 학습한 상태에서 학습률(LR)이 너무 높을 경우, 기존의 유용한 지식이 손상되는 **'Catastrophic Forgetting'** 현상이 발생하며 학습이 불안정해졌습니다.

* **해결책:**
    * **낮은 학습률 설정:** LR을 `1e-4` \~ `5e-5` 사이의 낮은 값으로 설정하여, 모델이 새로운 데이터를 천천히, 그리고 안정적으로 학습하도록 유도했습니다.
    * **Epoch 수 증가:** 학습률이 낮아진 만큼 수렴 속도가 느려지는 단점을 보완하기 위해, 전체 에폭(Epoch) 수를 비례적으로 늘려 충분한 학습 시간을 확보했습니다.

### (5) 하이퍼파라미터 튜닝: 시간 제약 속 신속한 탐색

* **문제점:** 챌린지 기간이 매우 짧아, Grid Search나 Bayesian Optimization과 같은 정형화된 하이퍼파라미터 튜닝을 수행할 시간이 절대적으로 부족했습니다. 8B 모델은 1회 학습에도 상당한 시간이 소요되므로, 모든 파라미터 조합을 미세하게 조정하는 것은 불가능했습니다.
* **해결책: "최적의 값" 대신 "효율적인 값"을 찾는 전략**을 채택했습니다.
    * **경험 기반 후보군 설정:** 학습률(LR), LoRA r, lora\_alpha 등 핵심 파라미터에 대해, 커뮤니티에서 검증된 값이나 경험적 "임의값"들을 몇 가지 유력한 후보로 우선 선정했습니다.
    * **신속한 검증 및 선택:** 전체 데이터가 아닌 소규모 샘플 데이터 또는 1-2 에폭(epoch)의 짧은 훈련만으로 각 후보군의 손실(Loss) 하락 추세를 빠르게 비교했습니다. 가장 안정적이고 빠른 수렴을 보이는 파라미터 조합을 즉시 채택했습니다.
* **결과:** "수학적 최적값"을 찾는 데 시간을 소모하는 대신, "제한된 시간 내 가장 효율적인" 파라미터셋을 신속하게 확보했습니다. 이를 통해 남은 시간을 본 학습의 안정화와 Softmax 추론 같은 다른 핵심 전략 개발에 투자할 수 있었습니다.

**하이퍼파라미터**

```text
-------------------------------
LoRA 관련 하이퍼파라미터
-------------------------------
r = 32                     # LoRA의 rank (저차원 공간의 차원 수)
lora_alpha = 32            # LoRA 보정 강도 
lora_dropout = 0.05        # LoRA 계층에 적용되는 dropout 비율 (과적합 방지용)

-------------------------------
학습 설정 관련 하이퍼파라미터
-------------------------------
learning_rate = 1e-4       # 학습률 
per_device_train_batch_size = 8   # GPU 한 장당 학습 배치 크기
gradient_accumulation_steps = 2   # 여러 step의 그래디언트를 누적해 1회 업데이트 (메모리 절약용)

# 실제로 한 번의 업데이트에 사용되는 전체 배치 크기
effective_batch_size = per_device_train_batch_size * gradient_accumulation_steps
# → 예: 8 * 2 = 16개의 샘플이 한 번의 업데이트에 반영됨

-------------------------------
정규화 및 일반화 관련
-------------------------------
weight_decay = 0.01        # 가중치 감쇠 계수 (큰 파라미터에 패널티를 주어 과적합 방지)

-------------------------------
학습 진행 관련
-------------------------------
num_train_epochs = 5        # 전체 데이터셋을 몇 번 반복 학습할지 (1 epoch = 전체 데이터 1회 학습)

# 전체 학습 스텝 수 계산
total_train_steps = math.ceil((len(train_dataset) * num_train_epochs) / effective_batch_size)
# → 전체 학습 데이터 크기와 배치 크기를 기반으로 총 스텝 수를 구함

-------------------------------
학습률 스케줄 관련
-------------------------------
warmup_steps = int(total_train_steps * 0.05)
# 워밍업 스텝 수 (전체 스텝의 5%)
# → 초기에는 학습률을 0에서 천천히 올려서 모델이 안정적으로 학습을 시작하도록 함
```

-----

## 6. 트러블 슈팅

### (1) 배치 사이즈 (Batch Size): VRAM 한계 극복

* **문제점:** 학습 안정성을 위해 배치 사이즈를 늘리고 싶었으나, 16 이상으로 설정 시 `CUDA: Out of Memory` 에러가 발생하며 40GB의 VRAM 한계를 초과했습니다.
* **해결책: 그라디언트 축적 (Gradient Accumulation)**
    * `gradient_accumulation_steps` 옵션을 활성화했습니다.
    * 이는 VRAM이 감당할 수 있는 작은 배치(예: `batch_size=8`)로 여러 번(예: `gradient_accumulation_steps = 2`) 그래디언트를 계산한 뒤, 이 값들을 메모리에 '축적'했다가 한 번에 모델 파라미터를 업데이트하는 방식입니다.
* **효과:** 실제로는 `batch_size=8`로 동작하지만, 모델은 `16 (8 * 2)`의 배치 사이즈로 학습하는 것과 동일한 안정적 효과를 얻어 VRAM의 물리적 한계를 우회했습니다.

### (2) 스케줄러 (Scheduler): 탐색과 수렴의 균형

* **문제점:** 단순한 `Linear` 스케줄러는 학습 초반의 빠른 탐색과 후반의 세밀한 수렴을 모두 만족시키기 어려웠습니다.
* **해결책: Cosine 스케줄러 적용**
    * 학습률 스케줄러를 '코사인(Cosine)' 방식으로 변경했습니다.
* **효과:** 학습 초반에는 비교적 높은 학습률로 넓은 영역을 빠르게 탐색하고, 학습이 진행될수록 코사인 곡선을 그리며 학습률을 부드럽게 감소시켰습니다. 이를 통해 학습 후반부에는 매우 낮은 학습률로 정답에 세밀하게 수렴(fine-tuning)하도록 유도하여 안정성과 성능을 동시에 확보했습니다.

### (3) GCP 인스턴스 Hugging Face 캐시 권한 오류

* **문제점:** 유독 GCP 인스턴스 환경에서만 Hugging Face Hub에서 사전 학습된 모델(Qwen3-VL)을 로드할 때 `Permission denied` 에러가 발생하며 스크립트가 중단되었습니다. (Kaggle, Colab에서는 정상 작동)
* **원인 분석:** 스크립트를 실행하는 유저 계정(team)이 Hugging Face가 모델을 임시 저장하는 캐시 디렉토리(`/opt/hf-cache`)에 대한 쓰기 권한이 없었습니다. 해당 폴더의 소유자가 `root`로 기본 설정되어 있었기 때문입니다.
* **해결책:** `sudo` 명령어를 통해 캐시 디렉토리와 그 하위 파일들의 소유권(`chown`)을 현재 스크립트 실행 계정(team)으로 변경하여 문제를 해결했습니다.
  ```bash
  # /opt/hf-cache 디렉토리와 그 하위(-R) 파일들의 소유권을 'team' 그룹의 'team' 유저로 변경
  !sudo chown -R team:team /opt/hf-cache
  ```

### (4) K-Fold 교차 검증: GPU 과부하 및 시간 비효율

* **문제점:** 모델의 일반화 성능을 검증하고 높이기 위해 5-Fold 교차 검증 도입을 시도했습니다. 하지만 4000여개의 전체 학습 데이터를 5회 반복 훈련시키는 것은 A100 40GB 단일 GPU 환경의 VRAM과 챌린지의 제한된 시간 내에서 심각한 GPU 과부하와 비현실적인 학습 시간을 초래했습니다.
* **해결책:**
    * **전략적 축소 적용:** K-Fold는 전체 데이터가 아닌, **소규모 샘플 데이터에만 제한적으로 사용**하여 하이퍼파라미터(예: LR, LoRA r값) 탐색의 신뢰도를 높이는 용도로만 활용했습니다.
    * **고정 스플릿으로 효율성 확보:** 실제 제출용 모델을 위한 **본 학습(Final Training)** 에서는, 80:20 등의 고정된 train/validation 스플릿을 사용했습니다. 이를 통해 5회 반복의 비효율을 제거하고, 확보된 자원과 시간을 단일 모델의 안정적인 수렴에 집중시켰습니다.

-----

## 7. 개선할 점과 배운점

### (1) 환경별 하드코딩된 경로 및 버전 관리 부재

* **문제점:** 각 환경(Kaggle, Colab, GCP)마다 데이터셋과 설정 파일의 절대 경로가 모두 달랐습니다.
    * `Kaggle`: `/kaggle/input/our-data/`
    * `Colab`: `/content/drive/MyDrive/project/`
    * `GCP`: `/home/team/project/data/`
* **악화 요인:** GitHub 등을 통한 체계적인 버전 관리가 이루어지지 않았습니다. `train_v3_final.py`, `train_v4_colab.py`와 같이 수정된 파일을 메신저로 수동 전달하는 방식은 파라미터 변경 이력 추적을 불가능하게 만들었고, 환경이 바뀔 때마다 매번 코드 내의 경로를 직접 수정해야 하는 비효율을 초래했습니다.
* **개선할 점:**
    * `os.environ`을 활용하여 `DATA_PATH`와 같은 환경 변수를 시스템별로 설정하고, 코드 내에서는 이 변수를 참조하도록 설계하여 환경 종속성을 제거해야 합니다.
    * Notion, GitHub, Git LFS를 도입하여 파라미터 변경 이력과 코드 버전을 중앙에서 관리해야 합니다.

### (2) 테스트 데이터 분포 변화(Domain Shift) 대응 부재

* **문제점:** 현재 모델은 훈련 데이터셋에 최적화되어 추론 시점에는 모든 가중치(Qwen-VL 8B + LoRA)가 **'고정(Frozen)'** 되기때문에. 훈련 데이터와 테스트 데이터의 분포(예: 조명, 각도, 스타일)가 미묘하게 다를 경우(Domain Shift), 모델의 성능이 저하됩니다.
* **악화 요인:** 현재의 TTA(Test-Time Augmentation)는 입력 데이터에 변형을 주어 예측을 '평균'내는 수동적(Passive) 방식입니다. 만약 테스트셋 전체가 특정 편향(예: 모두 '흐린 날' 사진)을 갖는다면, 모델이 이 편향에 '적응'하지 못하고 일관되게 낮은 확신도(High Entropy)로 예측하여 점수가 하락합니다.
* **개선할 점:**
    * **TENT (Test-Time Entropy Minimization)** 를 도입하여 능동적(Active) 적응을 수행하도록 합니다. 추론 시 테스트 배치마다 **엔트로피 손실(Entropy Loss)** 을 계산하고, 모델이 예측을 더 '확신'하는 방향으로 가중치의 일부를 실시간 업데이트합니다.
    * **SAR (Stochastic-Answer Regularization)** 을 함께 적용합니다. TENT의 과신(Overconfidence) 오류를 막기 위해, TTA를 결합하여 "증강된 이미지를 넣어도 예측이 일관되어야 한다"는 **일관성 손실(Consistency Loss)** 을 추가, 안정성을 높입니다.
    * **적용:** 8B 모델 전체가 아닌, 훈련된 LoRA 어댑터 가중치만 TENT/SAR 손실로 실시간 미세 조정하여(Online Adaptation) VRAM 부담 없이 테스트셋에 적응시킵니다.

### (3) VLM의 정적 프롬프트(Static Prompt) 한계

* **문제점:** 모든 테스트 이미지에 "관찰 $\rightarrow$ 추론 $\rightarrow$ 결론"이라는 동일한(Static) CoT 프롬프트를 사용하고 있습니다. 이는 VLM의 유연성을 100% 활용하지 못하는 방식입니다.
* **악화 요인:** 어떤 이미지는 '단순 관찰'만 필요하고(쉬운 문제), 어떤 이미지는 '복잡한 추론'(어려운 문제)이 필요합니다. 고정된 프롬프트는 '어려운' 이미지에 대해 최적의 질문을 던지지 못할 수 있습니다. 또한, Domain Shift로 인해 이미지와 텍스트 간의 임베딩 정렬(Alignment)이 깨져 모델이 오답을 선택할 위험이 있습니다.
* **개선할 점:**
    * **TPT (Test-Time Prompt Tuning):** 모델 가중치는 모두 동결하되, PEFT의 PromptTuning을 활용해 학습 가능한 '소프트 프롬프트' 벡터를 추가합니다. TENT 손실을 사용하여, 각 테스트 배치에 가장 최적화된 '질문(프롬프트)'을 실시간으로 탐색하고 업데이트합니다. VRAM 부담이 극히 적어 40GB 환경에 가장 적합합니다.
    * **(대안) PromptAlign:** TENT 손실을 LoRA 가중치에 역전파하여, 테스트 이미지 임베딩과 정답 텍스트 임베딩이 임베딩 공간에서 다시 '정렬'되도록 LoRA 어댑터를 실시간 보정합니다.

### (4) 하이퍼파라미터 튜닝: 제한된 시간 속에서 얻은 교훈

* **문제점:** 대회 기간이 매우 짧았기 때문에, Manual Search 기반의 하이퍼파라미터 탐색은 현실적으로 많은 시간이 소요되었습니다. 8B 모델은 한 번의 학습에도 상당한 연산 시간이 필요했기 때문에, 모든 조합을 실험적으로 검증하는 과정이 비효율적이었습니다.
* **당시의 접근:** 저희 팀은 시간 내 안정적인 결과 확보를 우선으로 하여, 학습률(LR), LoRA r, lora\_alpha 등의 주요 하이퍼파라미터를 경험적으로 설정하고, 소규모 데이터셋으로 손실 하락 추세를 빠르게 비교하며 최적 조합을 선택했습니다. 결과적으로 일정 수준의 성능은 확보했지만, 탐색 효율 측면에서는 한계가 있음을 느꼈습니다.
* **개선할 점:**
  이번 경험을 통해, 단순한 Grid Search 방식은 시간이 제한된 상황에서 비효율적이라는 점을 체감했습니다. 향후에는 **Bayesian Optimization**이나 **Hyperband**처럼 이전 실험 결과를 확률적으로 모델링하고, 성능이 높을 가능성이 있는 구간을 집중적으로 탐색하는 하이퍼파라미터 최적화 기법을 도입할 계획입니다. 이를 통해 제한된 자원과 시간 내에서도 더 빠르고 안정적으로 최적의 파라미터를 찾아내는 시스템적 접근을 구현하고자 합니다.
